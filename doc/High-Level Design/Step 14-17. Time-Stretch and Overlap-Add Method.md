### **Steps 14-17: Time-Stretch and Overlap-Add Method in Verilog**

In this phase of the design, we handle the time-stretching operation and reconstruct the time-domain signal using the overlap-add method. This involves:
1. **Time-Stretch**: Expanding or compressing the time axis of the signal.
2. **Phase Accumulation**: Adjusting the phase while stretching.
3. **Overlap-Add**: Reconstructing the time-domain signal by overlapping and adding the stretched frames.

---

### **Step 14: Time-Stretch Operation**

In a phase vocoder, time-stretching involves increasing or decreasing the number of frames by interpolating between existing frames in the STFT domain.

#### **High-Level Requirements**:
1. **Time Stretch Factor**: Determine the new number of frames based on the time stretch factor.
2. **Interpolate Magnitudes and Phases**: Interpolate between the magnitudes and phase values from the input STFT.

#### **Module 6: Time Stretching (Verilog)**

```verilog
module time_stretch (
    input clk,
    input rst,
    input signed [15:0] mag_in,  // Input magnitude
    input signed [15:0] phase_in,  // Input phase
    input [31:0] current_frame,  // Current frame index
    input [31:0] next_frame,     // Next frame index
    input [15:0] interp_factor,  // Interpolation factor (0 to 1)
    input valid_in,
    output reg signed [15:0] mag_out,  // Output interpolated magnitude
    output reg signed [15:0] phase_out,  // Output interpolated phase
    output reg valid_out
);

    reg signed [15:0] delta_phase;  // Difference between consecutive phases

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            mag_out <= 0;
            phase_out <= 0;
            valid_out <= 0;
        end else if (valid_in) begin
            // Interpolate magnitude
            mag_out <= (mag_in * (16'hFFFF - interp_factor) + next_frame * interp_factor) >>> 16;

            // Interpolate phase by adjusting delta between consecutive frames
            delta_phase <= next_frame - phase_in;
            if (delta_phase > 32767) delta_phase <= delta_phase - 65536;  // Wrap phase difference
            if (delta_phase < -32768) delta_phase <= delta_phase + 65536;
            phase_out <= phase_in + delta_phase;

            valid_out <= 1;
        end else begin
            valid_out <= 0;
        end
    end

endmodule
```

---

### **Explanation**:
1. **Interpolation**: We perform linear interpolation on both the magnitude and phase.
   - The `interp_factor` determines how far between two frames we are.
2. **Phase Unwrapping**: The phase difference (`delta_phase`) is adjusted using wrapping to handle phase discontinuities between consecutive frames.
3. **Output**: The module outputs the interpolated magnitude and phase for the stretched time axis.

---

### **Step 15: Phase Accumulation**

To ensure smooth phase continuity, the phase progression must be maintained during the time-stretching process.

#### **High-Level Requirements**:
1. **Accumulate Phase**: Adjust the phase for each frame using the unwrapped phase difference.
2. **Wrap Phase**: Keep the phase within the range of [-π, π].

#### **Module 7: Phase Accumulation (Verilog)**

```verilog
module phase_accumulation (
    input clk,
    input rst,
    input signed [15:0] phase_in,   // Input phase
    input signed [15:0] delta_phase,  // Phase difference between frames
    input valid_in,
    output reg signed [15:0] phase_out,  // Accumulated phase
    output reg valid_out
);

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            phase_out <= 0;
            valid_out <= 0;
        end else if (valid_in) begin
            // Accumulate phase difference
            phase_out <= phase_out + delta_phase;
            
            // Wrap the phase within [-π, π]
            if (phase_out > 32767) phase_out <= phase_out - 65536;
            if (phase_out < -32768) phase_out <= phase_out + 65536;

            valid_out <= 1;
        end else begin
            valid_out <= 0;
        end
    end

endmodule
```

---

### **Explanation**:
1. **Phase Accumulation**: The phase is updated using the phase difference (`delta_phase`) between consecutive frames.
2. **Phase Wrapping**: The phase is wrapped to ensure it remains within the valid range of [-π, π].
3. **Output**: The accumulated phase is output for each frame.

---

### **Step 16: Overlap-Add Reconstruction**

The overlap-add method reconstructs the time-domain signal by overlapping adjacent frames of the inverse FFT of the STFT and summing them together.

#### **High-Level Requirements**:
1. **Reconstruct Signal**: Use the inverse FFT (iFFT) to convert the STFT frames back to the time domain.
2. **Overlap and Add**: Overlap the frames and sum them to obtain the final signal.

#### **Module 8: Overlap-Add (Verilog)**

```verilog
module overlap_add (
    input clk,
    input rst,
    input signed [15:0] ifft_frame,  // Inverse FFT frame (time-domain sample)
    input [31:0] frame_index,        // Frame index
    input [31:0] hop_size,           // Hop size between frames
    input valid_in,
    output reg signed [15:0] audio_out,  // Reconstructed time-domain audio
    output reg valid_out
);

    reg signed [31:0] audio_buffer [0:65535];  // Buffer for overlap-add reconstruction
    reg [31:0] buffer_index;  // Index for audio buffer

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            buffer_index <= 0;
            valid_out <= 0;
        end else if (valid_in) begin
            // Overlap-add the current frame with previous samples
            buffer_index <= frame_index * hop_size;
            audio_buffer[buffer_index] <= audio_buffer[buffer_index] + ifft_frame;

            // Output the current reconstructed sample
            audio_out <= audio_buffer[buffer_index];
            valid_out <= 1;
        end else begin
            valid_out <= 0;
        end
    end

endmodule
```

---

### **Explanation**:
1. **Overlap-Add**: Each frame (inverse FFT result) is added to an overlapping portion of previous frames.
2. **Buffer**: The `audio_buffer` stores the accumulated samples to account for overlap.
3. **Hop Size**: The `hop_size` determines how far apart the frames are in time.
4. **Output**: The module outputs the reconstructed audio sample for each valid input.

---

### **Step 17: Inverse FFT for Time-Domain Conversion**

To convert the stretched STFT frames back to the time domain, we need to perform the inverse FFT on each frame. This step can be done using a pre-existing FFT core in Xilinx Vivado.

#### **High-Level Requirements**:
1. **Use FFT IP Core**: Implement the inverse FFT using the Xilinx FFT IP core.
2. **Feed STFT Frames**: Input the stretched STFT frames into the inverse FFT core.
3. **Receive Time-Domain Output**: Obtain the time-domain frames from the inverse FFT.

---

### **Summary of Steps 14-17**:
1. **Step 14**: The time-stretching module interpolates magnitudes and phases between frames to expand or compress the signal in time.
2. **Step 15**: The phase accumulation module ensures smooth phase continuity during time-stretching by adjusting the phase difference between consecutive frames.
3. **Step 16**: The overlap-add method reconstructs the time-domain signal by summing overlapping frames after inverse FFT.
4. **Step 17**: The inverse FFT is performed on the stretched STFT frames to convert them back into the time domain.

---

### **Next Steps**:
Would you like to proceed with the Verilog testbench for these modules, or focus on the integration with other components (e.g., the FFT core)?
