### **Step 14: Inverse FFT (IFFT) Module**

Now that we have the time-stretched magnitude and phase, the next task is to convert these values back into the time domain using the **Inverse Fast Fourier Transform (IFFT)**. This step will allow us to reconstruct the audio signal from its frequency components.

### **IFFT Overview**
- The IFFT takes frequency-domain data (magnitude and phase) and converts it back to a time-domain signal.
- In this phase vocoder, we use the IFFT to reconstruct each time frame of the audio after time-stretching.

### **Xilinx Vivado IFFT IP Core**

We will utilize the **IFFT IP core** provided by Xilinx to handle the inverse FFT computation. This IP core is highly optimized for FPGA implementations and supports the following key features:
- Configurable FFT size (matches our FFT size of 1024).
- Input in fixed-point format.
- Pipelined operation for high-throughput systems.

#### **Steps for IFFT in Vivado**:
1. **Instantiate the Xilinx IFFT IP Core**: The core can be customized for a 1024-point IFFT with fixed-point input.
2. **Prepare the Data Format**: The inputs to the IFFT will be the real and imaginary parts of the frequency-domain signal (magnitude and phase).
3. **Perform IFFT**: The IFFT converts the frequency-domain signal back to time-domain.
4. **Overlap-Add**: The output frames are overlapped and added to reconstruct the continuous time-domain signal.

### **Configuring the Xilinx IFFT IP Core**

#### **Key Configuration Parameters**:
- **Transform Length**: 1024 points (same as the STFT size).
- **Input Data Format**: Fixed-point (16 bits real and 16 bits imaginary).
- **Output Scaling**: Enable automatic scaling to avoid overflow.
- **Symmetry Mode**: Use for real input signals.

To instantiate the IP core, follow these steps in Vivado:

1. **Open IP Catalog**: Go to the **IP Catalog** in Vivado and search for "FFT" or "IFFT".
2. **Configure FFT IP Core**:
   - **Transform Size**: Set to 1024.
   - **Input Data Width**: 16 bits for both real and imaginary parts.
   - **Scaling Options**: Enable automatic scaling.
   - **Symmetry Mode**: Enable for real inputs.
   - **Architecture**: Choose **Pipelined Streaming** for continuous data processing.

3. **Generate and Customize** the IFFT IP core based on your design requirements.

---

### **Module 5: IFFT Wrapper (Verilog)**

After configuring the Xilinx IFFT IP core, we wrap it in a module that interfaces with our time-stretching system.

#### **IFFT Wrapper Module**:

```verilog
module ifft_wrapper (
    input clk,
    input rst,
    input valid_in,
    input [15:0] real_in,       // Real part of the frequency-domain signal
    input [15:0] imag_in,       // Imaginary part of the frequency-domain signal
    output reg valid_out,
    output [15:0] real_out,     // Real part of the time-domain signal (output of IFFT)
    output [15:0] imag_out      // Imaginary part of the time-domain signal (output of IFFT)
);

    // IFFT IP core instantiation
    wire [15:0] ifft_real_out;
    wire [15:0] ifft_imag_out;
    wire ifft_valid;

    // Xilinx IFFT IP Core Instance
    xfft_0 your_ifft_instance (
        .aclk(clk),
        .s_axis_config_tdata(16'b0),       // IFFT configuration (default)
        .s_axis_config_tvalid(1'b1),       // Configuration always valid
        .s_axis_data_tdata({real_in, imag_in}),  // Input data: real and imaginary parts
        .s_axis_data_tvalid(valid_in),     // Valid input signal
        .s_axis_data_tready(),             // Data ready (not used in simple cases)
        .m_axis_data_tdata({ifft_real_out, ifft_imag_out}),  // Output data: real and imaginary parts
        .m_axis_data_tvalid(ifft_valid)    // Valid output signal
    );

    // Assign outputs
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            valid_out <= 1'b0;
        end else begin
            valid_out <= ifft_valid;
        end
    end

    assign real_out = ifft_real_out;
    assign imag_out = ifft_imag_out;

endmodule
```

### **Explanation**:
1. **Inputs**:
   - The real and imaginary parts of the frequency-domain signal are fed into the IFFT.
   - These inputs correspond to the time-stretched magnitude and adjusted phase values.
2. **IFFT IP Core**:
   - The IFFT core takes the complex-valued frequency-domain data and converts it back to the time domain.
   - The core outputs the real and imaginary parts of the time-domain signal.
3. **Output**:
   - The real part of the IFFT output corresponds to the time-domain audio frame.
   - The imaginary part should be near zero and can be discarded in most cases.
4. **Valid Signals**:
   - The `valid_in` signal indicates when the input data is valid.
   - The `valid_out` signal indicates when the output of the IFFT is valid.

---

### **Step 15: Testbench for IFFT Module**

Let's create a testbench to verify the behavior of the IFFT wrapper module.

#### **Testbench for IFFT**:

```verilog
module tb_ifft_wrapper();

    reg clk;
    reg rst;
    reg valid_in;
    reg [15:0] real_in;
    reg [15:0] imag_in;
    wire valid_out;
    wire [15:0] real_out;
    wire [15:0] imag_out;

    // Instantiate the IFFT wrapper
    ifft_wrapper uut (
        .clk(clk),
        .rst(rst),
        .valid_in(valid_in),
        .real_in(real_in),
        .imag_in(imag_in),
        .valid_out(valid_out),
        .real_out(real_out),
        .imag_out(imag_out)
    );

    // Clock generation
    always begin
        #5 clk = ~clk;  // 10ns clock period (100 MHz)
    end

    // Test scenario
    initial begin
        // Initialize
        clk = 0;
        rst = 1;
        valid_in = 0;
        real_in = 16'd0;
        imag_in = 16'd0;

        // Release reset
        #10 rst = 0;

        // Apply some test inputs
        #10 valid_in = 1;
        real_in = 16'd5000;  // Example real input
        imag_in = 16'd0;     // Example imaginary input

        #10 valid_in = 1;
        real_in = 16'd3000;
        imag_in = 16'd0;

        // Wait for output
        #50;
        $stop;
    end
endmodule
```

### **Explanation**:
- The testbench initializes the clock and reset signals.
- It feeds some test data into the IFFT wrapper (real and imaginary parts) and verifies that the output is valid after the IFFT operation.
- The output `real_out` will be the reconstructed time-domain signal.

---

### **Step 16: Synthesize and Simulate**

1. **Synthesize** the IFFT wrapper and connect it to the time-stretching system.
2. **Simulate** the testbench:
   - Verify that the real part of the output corresponds to the time-domain signal.
   - Check that the IFFT outputs valid data when the input is valid.
