**Vivado FFT IP Core Setup**
Vivado provides an FFT IP core that handles the Fast Fourier Transform efficiently. The FFT core can operate in pipelined mode to allow continuous processing of incoming data.

Configuration of FFT IP Core in Vivado:
1. Open Vivado and create a new project targeting your FPGA board (e.g., Spartan S7-25).
 - Add the FFT IP Core to your project:
 - Go to Tools > IP Catalog.
 - Search for "FFT" in the IP catalog.
2. Add the Xilinx FFT IP to your project.
3. Configure the FFT IP:
 - Set the FFT size to 1024 points (same as in the MATLAB implementation).
 - Enable pipelined streaming mode to allow continuous data processing.
 - Set the input data width to match your audio sample format (e.g., 16 bits).
 - Use a scaling schedule if necessary to handle the output range of the FFT.


```
module fft_module (
    input clk,
    input rst,
    input valid_in,
    input [15:0] audio_frame,  // 16-bit audio sample input
    output reg [15:0] fft_real_out,  // Real part of FFT output
    output reg [15:0] fft_imag_out,  // Imaginary part of FFT output
    output reg valid_out
);
    // Wires for FFT core
    wire [15:0] fft_real;
    wire [15:0] fft_imag;
    wire fft_valid;
    
    // FFT IP core instantiation
    fft_ip fft_inst (
        .aclk(clk),
        .s_axis_config_tvalid(1'b1),  // Config always valid
        .s_axis_data_tvalid(valid_in),  // Input data valid
        .s_axis_data_tdata(audio_frame),  // Audio sample input
        .m_axis_data_tvalid(fft_valid),  // Output data valid
        .m_axis_data_tdata({fft_real, fft_imag})  // FFT output (real and imaginary)
    );
    
    // Output assignment
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            fft_real_out <= 16'd0;
            fft_imag_out <= 16'd0;
            valid_out <= 1'b0;
        end else if (fft_valid) begin
            fft_real_out <= fft_real;
            fft_imag_out <= fft_imag;
            valid_out <= 1'b1;
        end else begin
            valid_out <= 1'b0;
        end
    end
endmodule
```

Now, let's write a testbench to verify that the FFT module works correctly. The testbench will feed in a few audio samples and verify that the FFT output is generated.

```
module tb_fft_module();

    reg clk;
    reg rst;
    reg valid_in;
    reg [15:0] audio_frame;
    wire [15:0] fft_real_out;
    wire [15:0] fft_imag_out;
    wire valid_out;
    
    // Instantiate the FFT module
    fft_module uut (
        .clk(clk),
        .rst(rst),
        .valid_in(valid_in),
        .audio_frame(audio_frame),
        .fft_real_out(fft_real_out),
        .fft_imag_out(fft_imag_out),
        .valid_out(valid_out)
    );
    
    // Clock generation (100 MHz)
    always begin
        #5 clk = ~clk;
    end
    
    // Test scenario
    initial begin
        // Initialize
        clk = 0;
        rst = 1;
        valid_in = 0;
        audio_frame = 16'd0;
        
        // Release reset
        #10 rst = 0;
        
        // Feed audio samples
        #10 valid_in = 1;
        audio_frame = 16'd200;
        #10 valid_in = 1;
        audio_frame = 16'd300;
        #10 valid_in = 1;
        audio_frame = 16'd400;
        #10 valid_in = 1;
        audio_frame = 16'd500;
        
        // Wait for FFT output
        #50;
        $stop;
    end
endmodule
```

**Synthesize and Simulate**
1. Synthesize the FFT module in Vivado to ensure that it fits within the FPGA's resources.
2. Simulate the testbench in Vivado:
 - The simulation will show if the FFT is correctly calculating the real and imaginary parts of the input signal.
 - Check the output values of fft_real_out, fft_imag_out, and valid_out to verify correctness.
